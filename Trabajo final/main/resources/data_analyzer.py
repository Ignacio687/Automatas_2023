import pathlib, datetime, os, re, multiprocessing

class IncorrectFileExtensionError(Exception):
    pass

class modeIndexOutOfRangeError(Exception):
    pass

class DataAnalyzer():
    def __init__(self, filePath: str | pathlib.Path) -> None:
        """Class capable of validating a specific format csv file and 
        returning filtered data.\n
        filePath: Absolute path of the file"""
        self.filePath = filePath

    def setFilePath(self, filePath: str) -> None:
        """"Resets the current file path."""
        self.filePath = filePath

    def validate(self) -> dict[int, tuple[int, str]]:
        """Method capable of validating the file format and all data within the lines. 
        Returns a dictionary with all the found errors '{line_index:(header, error)}'."""
        file = open(self.filePath, "r")
        headers = file.readline().split(",")
        if os.path.splitext(self.filePath)[1] != ".csv":
            file.close()
            raise IncorrectFileExtensionError("Not a 'csv' type file")
        pool = multiprocessing.Pool()
        fileLines = file.readlines()
        arguments = ((line, index+2, headers) for index, line in enumerate(fileLines))
        errorsList = pool.starmap(self.subprocessValidation, arguments)
        errorsDict = {}
        for errorDict in errorsList:
            if errorDict != {}:
                errorsDict.update(errorDict)
        file.close()
        return errorsDict
        

    def subprocessValidation(self, line, index, headers) -> dict[int, tuple[str, str]]:
        """Method designed to be run by a subprocess generated by the 'validate' method"""
        errorsDict = {}
        line = line.replace(",,", ",").split(",")
        modeList = [0,1,2,3,4,5,6,7,6,7,8,8,8,9,10]
        for column in range(0, len(modeList)):
            validation = self.expValidation(str(line[column]), modeList[column])
            if not validation:
                errorsDict[index] = (str(headers[column]), str(line[column]))
                break
        return errorsDict


    def expValidation(self, expresion: str, mode: int) -> bool:
        """Method designed to evaluates if a given expresion is valid.\n
        mode: specifies the regular expresion used:\n
        00 - ID\n
        01 - ID_Sesion\n
        02 - ID_Conexión_unico\n
        03 - Usuario\n
        04 - IP_NAS_AP\n
        05 - Tipo__conexión\n
        06 - Inicio_de_Conexión_Dia/Fin_de_Conexión_Dia\n
        07 - Inicio_de_Conexión_Hora/Fin_de_Conexión_Hora\n
        08 - Session_Time/Input_Octects/Output_Octects\n
        09 - MAC_AP\n
        10 - MAC_Cliente\n"""
        regExpList = [
            r"[0-9]+",
            r"[0-9A-F]{1,8}-?[0-9A-F]{1,8}",
            r"[0-9a-f]{8,16}",
            r"[\w\.-]+",
            r"((2([0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])\.){3}(2([0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])",
            r"Wireless-802.11",
            r"(\d{4})(-)(0?[1-9]|1[012])\2(0?[1-9]|[12][0-9]|3[01])",
            r"([01][0-9]|2[0-4]):([0-5][0-9]|60):([0-5][0-9]|60)",
            r"([1-9][0-9]*)|0",
            r"([0-9A-F]{2}-){5}[0-9A-F]{2}:HCDD",
            r"([0-9A-F]{2}-){5}[0-9A-F]{2}"
        ]
        if mode not in range(0,13):
            raise modeIndexOutOfRangeError(f"{mode} is not a mode option")
        regExp = re.compile(regExpList[mode])
        if regExp.fullmatch(expresion):
            return True
        else: return False

    def generateFile(self, path: pathlib.Path | None = None, lines: tuple | None = None) -> str:
        """Method designed to copy the original file, with or without removing lines, 
        into a new directory. Returns the new file absolute path.\n
        path: Absolute directory path where the new file will be.\n
        lines: Indexes of lines willing to remove."""
        if path == None:
            path = pathlib.Path.cwd().joinpath("main", "data")
        fileName = pathlib.Path(self.filePath).name.replace(".csv", "")
        path = path.joinpath(f"{fileName}_filtered.csv")
        with open(self.filePath, "r") as file:
            fileLines = file.readlines()
        if lines != None:
            linesToRemove = list(lines)
            linesToRemove.sort(reverse=True)
            for line in linesToRemove:
                if line-1 in range(1, len(fileLines)):
                    fileLines.pop(line-1)
        with open(path, "w") as file:
            file.writelines(fileLines)
            file.flush()
        self.filePath = path.__str__()
        return path.__str__()

    def filterUsers(self, 
                    filter: bool = True, 
                    startDate: datetime.datetime|None = None, 
                    endDate: datetime.datetime|None = None
                    ) -> dict[str, tuple[datetime.datetime, str, str, int, int]]:
        """Method designed to filter the users that have accessed the system on Non-working days. 
        Returns a dictionary {user_name: [total_session_time, most_used_MAC_NWD, most_used_MAC_WD, 
        total_input_octects, total_output_octects]}  *NWD = Non-working days * WD = Working days\n
        filter: if set to False method returns complete list of users\n
        startDate/endDate: if either of them is set to None, the method will take the most old or 
        new date available respectively."""
        pass