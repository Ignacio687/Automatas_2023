import pathlib, datetime, os, re, multiprocessing

class IncorrectFileExtensionError(Exception):
    pass

class modeIndexOutOfRangeError(Exception):
    pass

class DataAnalyzer():
    def __init__(self, filePath: str) -> None:
        """Class capable of validating a specific format csv file and 
        returning filtered data.\n
        filePath: Absolute path of the file"""
        self.filePath = filePath

    def setFilePath(self, filePath: str) -> None:
        """"Resets the current file path."""
        self.filePath = filePath

    def validate(self) -> dict[int, tuple[int, str]]:
        """Method capable of validating the file format and all data within the lines. 
        Returns a dictionary with all the found errors '{line_index:(header, error)}'."""
        file = open(self.filePath, "r")
        file.readline()
        firstLine = file.tell()
        file.close()
        if os.path.splitext(self.filePath)[1] != ".csv":
            file.close()
            raise IncorrectFileExtensionError("Not a 'csv' type file")
        pool = multiprocessing.Pool()
        lock = multiprocessing.Manager().Lock()
        queue = multiprocessing.Manager().Queue()
        queue.put(firstLine)
        queue.put(1)
        proccesAmount = os.cpu_count() if os.cpu_count() != None else 4
        arguments = ((process, queue, lock) for process in range(0, proccesAmount)) # type: ignore
        errorsList = pool.starmap(self.subprocessValidation, arguments)
        errorsDict = {}
        for errorDict in errorsList:
            errorsDict.update(errorDict)
        return errorsDict
        

    def subprocessValidation(self, process: int, queue, lock) -> dict[int, tuple[int, str]]:
        """Method designed to be run by a subprocess generated by the 'validate' method"""
        file = open(self.filePath, 'r')
        headers = file.readline().split(",")
        errorsDict = {}
        while True:
            with lock:
                file.seek(queue.get())
                lineIndex = queue.get()
                line = file.readline().split(",")
                queue.put(file.tell())
            if line[0] == '':
                queue.put(lineIndex)
                break
            queue.put(lineIndex+1)
            modeList = [0,1,2,3,4,5,6,7,6,7,8,8,8,9,10]
            for column in range(0, len(modeList)):
                validation = self.expValidation(str(line[column]), modeList[column])
                if not validation and str(line[column]) == '':
                    errorsDict[lineIndex+1] = (headers[column], "Missing data")
                    break
                elif not validation:
                    errorsDict[lineIndex+1] = (headers[column], str(line[column]))
                    break
        file.close()
        return errorsDict


    def expValidation(self, expresion: str, mode: int) -> bool:
        """Method designed to evaluates if a given expresion is valid.\n
        mode: specifies the regular expresion used:\n
        00 - ID\n
        01 - ID_Sesion\n
        02 - ID_Conexión_unico\n
        03 - Usuario\n
        04 - IP_NAS_AP\n
        05 - Tipo__conexión\n
        06 - Inicio_de_Conexión_Dia/Fin_de_Conexión_Dia\n
        07 - Inicio_de_Conexión_Hora/Fin_de_Conexión_Hora\n
        08 - Session_Time/Input_Octects/Output_Octects\n
        09 - MAC_AP\n
        10 - MAC_Cliente\n"""
        regExpList = [
            r"[0-9]+",
            r"[0-9A-F]{1,8}-?[0-9A-F]{1,8}",
            r"[0-9a-f]{16}",
            r"[\w\.-]+",
            r"((2([0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])\.){3}(2([0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])",
            r"Wireless-802.11",
            r"(\d{4})(-)(0?[1-9]|1[012])\2(0?[1-9]|[12][0-9]|3[01])",
            r"([01][0-9]|2[0-4]):([0-5][0-9]|60):([0-5][0-9]|60)",
            r"([1-9][0-9]*)|0",
            r"([0-9A-F]{2}-){5}[0-9A-F]{2}:HCDD",
            r"([0-9A-F]{2}-){5}[0-9A-F]{2}"
        ]
        if mode not in range(0,13):
            raise modeIndexOutOfRangeError(f"{mode} is not a mode option")
        regExp = re.compile(regExpList[mode])
        if regExp.fullmatch(expresion):
            return True
        else: return False

    def generateFile(self, path: str, lines: tuple[int]|None = None) -> str:
        """Method designed to copy the original file, with or without removing lines, 
        into a new directory. Returns the new file absolute path.\n
        path: Absolute path where the new file will be.\n
        lines: Indexes of lines willing to remove."""
        pass

    def filterUsers(self, 
                    filter: bool = True, 
                    startDate: datetime.datetime|None = None, 
                    endDate: datetime.datetime|None = None
                    ) -> dict[str, tuple[datetime.datetime, str, str, int, int]]:
        """Method designed to filter the users that have accessed the system on Non-working days. 
        Returns a dictionary {user_name: [total_session_time, most_used_MAC_NWD, most_used_MAC_WD, 
        total_input_octects, total_output_octects]}  *NWD = Non-working days * WD = Working days\n
        filter: if set to False method returns complete list of users\n
        startDate/endDate: if either of them is set to None, the method will take the most old or 
        new date available respectively."""
        pass