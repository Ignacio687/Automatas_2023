import pathlib, datetime, os, re, multiprocessing, threading

class IncorrectFileExtensionError(Exception):
    pass

class modeIndexOutOfRangeError(Exception):
    pass

class DataAnalyzer():
    def __init__(self, filePath: str) -> None:
        """Class capable of validating a specific format csv file and 
        returning filtered data.\n
        filePath: Absolute path of the file"""
        self.filePath = filePath

    def setFilePath(self, filePath: str) -> None:
        """"Resets the current file path."""
        self.filePath = filePath

    def validate(self, subProc: int = 12) -> dict[int, str|int]:
        """Method capable of validating the file format and all data within the lines. 
        Returns a dictionary with all the found errors '{line_index:[errors_list]}'."""
        file = open(self.filePath, "r")
        if os.path.splitext(self.filePath)[1] != ".csv":
            file.close()
            raise IncorrectFileExtensionError("Not a 'csv' type file")

### ver que representa el campo de session time

    def subprocessExc(self, index: int, file) -> dict[int, str|int]:
        """Method designed to be run by a subprocess generated by the 'validate' method"""
        

    def expValidation(self, expresion: str, mode: int) -> bool:
        """Method designed to evaluates if a given expresion is valid.\n
        mode: specifies the regular expresion used:\n
        00 - ID\n
        01 - ID_Sesion\n
        02 - ID_Conexión_unico\n
        03 - Usuario\n
        04 - IP_NAS_AP\n
        05 - Tipo__conexión\n
        06 - Inicio_de_Conexión_Dia/Fin_de_Conexión_Dia\n
        07 - Inicio_de_Conexión_Hora/Fin_de_Conexión_Hora\n
        08 - Session_Time/Input_Octects/Output_Octects\n
        09 - MAC_AP\n
        10 - MAC_Cliente\n"""
        regExpList = [
            r"[0-9]+",
            r"[0-9A-F]{1,8}-?[0-9A-F]{1,8}",
            r"[0-9a-f]{16}",
            r"[\w\.-]+",
            r"((2([0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])\.){3}(2([0-4][0-9]|5[0-5])|[0-1]?[0-9]?[0-9])",
            r"Wireless-802.11",
            r"(\d{4})(-)(0?[1-9]|1[012])\2(0?[1-9]|[12][0-9]|3[01])",
            r"([01][0-9]|2[0-4]):([0-5][0-9]|60):([0-5][0-9]|60)",
            r"([1-9][0-9]*)|0",
            r"([0-9A-F]{2}-){5}[0-9A-F]{2}:HCDD",
            r"([0-9A-F]{2}-){5}[0-9A-F]{2}"
        ]
        if mode not in range(0,13):
            raise modeIndexOutOfRangeError(f"{mode} is not a mode option")
        regExp = re.compile(regExpList[mode])
        if regExp.fullmatch(expresion):
            return True
        else: return False

    def generateFile(self, path: str, lines: tuple[int]|None = None) -> str:
        """Method designed to copy the original file, with or without removing lines, 
        into a new directory. Returns the new file absolute path.\n
        path: Absolute path where the new file will be.\n
        lines: Indexes of lines willing to remove."""
        pass

    def filterUsers(self, 
                    filter: bool = True, 
                    startDate: datetime.datetime|None = None, 
                    endDate: datetime.datetime|None = None
                    ) -> dict[str, tuple[datetime.datetime, str, str, int, int]]:
        """Method designed to filter the users that have accessed the system on Non-working days. 
        Returns a dictionary {user_name: [total_session_time, most_used_MAC_NWD, most_used_MAC_WD, 
        total_input_octects, total_output_octects]}  *NWD = Non-working days * WD = Working days\n
        filter: if set to False method returns complete list of users\n
        startDate/endDate: if either of them is set to None, the method will take the most old or 
        new date available respectively."""
        pass